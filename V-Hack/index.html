<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar Vortex Shader</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      color: white;
    }
    .effect-controls {
      margin-top: 10px;
      border-top: 1px solid #333;
      padding-top: 10px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
<div id="controls">
  <label>Speed: <input type="range" id="speed" min="0" max="3" step="0.1" value="1.5"></label><br>
  <label>Arms: <input type="range" id="arms" min="1" max="12" step="1" value="6"></label><br>
  <label>Color: <input type="color" id="color" value="#ff8800"></label>
  <div class="effect-controls">
    <label>Bloom: <input type="range" id="bloom" min="0" max="2" step="0.1" value="0.5"></label><br>
    <label>Noise: <input type="range" id="noise" min="0" max="1" step="0.1" value="0.1"></label><br>
    <label>Distortion: <input type="range" id="distortion" min="0" max="1" step="0.1" value="0.0"></label>
  </div>
</div>
<canvas id="glcanvas"></canvas>
<script type="x-shader/x-fragment" id="fragShader">
precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform vec3 u_color;
uniform float u_speed;
uniform float u_arms;
uniform float u_bloom;
uniform float u_noise;
uniform float u_distortion;
uniform float u_depth;
uniform mat4 u_viewMatrix;

#define PI 3.14159265359

float noise(vec2 p) {
  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

float fbm(vec2 p) {
    float sum = 0.0;
    float amp = 1.0;  // increased from 0.5
    float freq = 1.0;
    for(int i = 0; i < 4; i++) {  // increased octaves
        sum += amp * noise(p * freq);
        freq *= 2.1;  // slightly modified frequency multiplier
        amp *= 0.5;
    }
    return sum * 2.0 - 1.0;  // normalize to [-1, 1] range
}

varying vec3 vPosition;
varying vec2 vUv;

void main() {
    vec2 uv = vUv;
    vec3 pos = vPosition;
    
    // Enhanced 3D space distortion
    vec3 center3D = pos;
    float dist3D = length(center3D);
    
    // Calculate spherical coordinates
    float theta = atan(center3D.y, center3D.x);
    float phi = acos(center3D.z / (dist3D + 0.0001));
    
    // Enhanced 3D distortion
    float timeScale = u_time * 0.2;  // slowed down time
    vec3 fbmVal3D = vec3(
        fbm(pos.xy + vec2(timeScale, 0.0)),
        fbm(pos.yz + vec2(timeScale * 1.1, 0.0)),
        fbm(pos.xz + vec2(timeScale * 0.9, 0.0))
    );
    
    vec3 distortedPos = pos + fbmVal3D * u_distortion * 0.5;  // increased effect
    
    // Apply distortion to the coordinates used for the swirl
    theta += fbmVal3D.x * u_distortion * 2.0;
    phi += fbmVal3D.y * u_distortion * 2.0;
    
    // 3D swirl effect with distortion
    float swirl = sin(theta * u_arms + phi * 2.0 - u_time * u_speed) * 0.3 + 0.5;
    float glow = exp(-8.0 * abs(length(distortedPos) - swirl));  // use distorted position
    
    // Add depth-based effects
    glow *= exp(-dist3D * 2.0);
    
    vec3 color = vec3(0.0);
    color += u_color * glow;
    color += vec3(1.0) * (glow * 0.5);
    
    // Add bloom and noise effects
    color += vec3(noise(uv * 100.0 + u_time)) * u_noise * 0.1;
    float bloom = u_bloom * glow * 2.0;
    color += color * bloom;
    
    gl_FragColor = vec4(color, glow * 0.8);
}  
</script>
<script type="x-shader/x-vertex" id="vertShader">
varying vec2 vUv;
varying vec3 vPosition;

void main() {
    vUv = uv;
    vPosition = position;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script>
const canvas = document.getElementById("glcanvas");
const renderer = new THREE.WebGLRenderer({ 
    canvas,
    antialias: true,
    alpha: true
});
renderer.setPixelRatio(window.devicePixelRatio);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.z = 1;

// Add orbit controls
const controls = new THREE.OrbitControls(camera, canvas);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.screenSpacePanning = false;
controls.minDistance = 0.5;
controls.maxDistance = 2;
controls.enableRotate = true;
controls.enableZoom = true;

// Create shader material
const shaderMaterial = new THREE.ShaderMaterial({
    uniforms: {
        u_time: { value: 0 },
        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        u_mouse: { value: new THREE.Vector2() },
        u_color: { value: new THREE.Vector3(1, 0.5, 0) },
        u_speed: { value: 1.5 },
        u_arms: { value: 6 },
        u_bloom: { value: 0.5 },
        u_noise: { value: 0.1 },
        u_distortion: { value: 0.2 },
        u_depth: { value: 1.0 },
        u_viewMatrix: { value: new THREE.Matrix4() }
    },
    vertexShader: document.getElementById("vertShader").textContent,
    fragmentShader: document.getElementById("fragShader").textContent,
    transparent: true,
    side: THREE.DoubleSide
});

// Create multiple planes for 3D effect
const planes = [];
const numPlanes = 8;
for(let i = 0; i < numPlanes; i++) {
    const angle = (i / numPlanes) * Math.PI * 2;
    const radius = 0.5;
    
    const geometry = new THREE.PlaneGeometry(2, 2, 32, 32);
    const material = shaderMaterial.clone();
    const plane = new THREE.Mesh(geometry, material);
    
    plane.position.x = Math.cos(angle) * radius;
    plane.position.z = Math.sin(angle) * radius;
    plane.rotation.y = -angle;
    
    planes.push(plane);
    scene.add(plane);
}

// Mouse tracking with normalized coordinates
let mouseX = 0, mouseY = 0;
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) / rect.width;
    mouseY = 1 - (e.clientY - rect.top) / rect.height;
    shaderMaterial.uniforms.u_mouse.value.set(mouseX * window.innerWidth, mouseY * window.innerHeight);
});

// Control handlers
function hexToRGB(hex) {
  const r = parseInt(hex.slice(1,3), 16) / 255;
  const g = parseInt(hex.slice(3,5), 16) / 255;
  const b = parseInt(hex.slice(5,7), 16) / 255;
  return [r, g, b];
}

let speed = 1.5;
let arms = 6;
let color = hexToRGB('#ff8800');
let bloom = 0.5;
let noiseAmount = 0.1;
let distortion = 0.0;

document.getElementById('speed').addEventListener('input', (e) => {
  speed = parseFloat(e.target.value);
});

document.getElementById('arms').addEventListener('input', (e) => {
  arms = parseFloat(e.target.value);
});

document.getElementById('color').addEventListener('input', (e) => {
  color = hexToRGB(e.target.value);
});

document.getElementById('bloom').addEventListener('input', (e) => {
  bloom = parseFloat(e.target.value);
});

document.getElementById('noise').addEventListener('input', (e) => {
  noiseAmount = parseFloat(e.target.value);
});

document.getElementById('distortion').addEventListener('input', (e) => {
  distortion = parseFloat(e.target.value);
});

function render(t) {
    const time = t * 0.001;
    
    planes.forEach((plane, i) => {
        const material = plane.material;
        material.uniforms.u_time.value = time;
        material.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
        material.uniforms.u_speed.value = speed;
        material.uniforms.u_arms.value = arms;
        material.uniforms.u_color.value.set(color[0], color[1], color[2]);
        material.uniforms.u_bloom.value = bloom;
        material.uniforms.u_noise.value = noiseAmount;
        material.uniforms.u_distortion.value = distortion;
        material.uniforms.u_viewMatrix = camera.matrixWorldInverse;
    });

    controls.update();
    renderer.render(scene, camera);
    requestAnimationFrame(render);
}

// Handle window resize
window.addEventListener('resize', () => {
  const width = window.innerWidth;
  const height = window.innerHeight;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
  shaderMaterial.uniforms.u_resolution.value.set(width, height);
});

renderer.setSize(window.innerWidth, window.innerHeight);
render(0);
</script>
</body>
</html>
