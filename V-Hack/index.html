<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar Vortex Shader</title>
  <script src="shaders.js"></script>
  <style>
    body { 
      margin: 0; 
      overflow: hidden; 
      background: black;
        background-image: 
        radial-gradient(circle at var(--mouse-x, 50%) var(--mouse-y, 50%), 
          rgba(255, 136, 0, 0.15) 0%, 
          transparent 150px),
        linear-gradient(rgba(255, 136, 0, 0.1) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 136, 0, 0.1) 1px, transparent 1px),
        linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
      background-size: 100% 100%, 100px 100px, 100px 100px, 20px 20px, 20px 20px;
      background-position: 0 0, 0 0, 0 0, 0 0, 0 0;
      transition: background-position 0.05s;
    }
    canvas { width: 100vw; height: 100vh; display: block; }
    #controls {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.85);
      padding: 38px;
      border-radius: 8px;
      color: white;
      border: 1px solid rgba(255, 136, 0, 0.3);
      transform: translateX(100%);
      transition: transform 0.3s ease;
    }
    #controls.visible {
      transform: translateX(0);
    }
    .effect-controls {
      margin-top: 10px;
      border-top: 1px solid rgba(255, 136, 0, 0.3);
      padding-top: 10px;
    }
    #toggleControls {
      position: fixed;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.85);
      color: white;
      border: 1px solid rgba(255, 136, 0, 0.3);
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 1000;
    }
    #toggleControls:hover {
      background: rgba(255, 136, 0, 0.2);
    }
    input[type="range"] {
      accent-color: #ff8800;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
<button id="toggleControls">Controls ⚙️</button>
<div id="controls">
  <label>Speed: <input type="range" id="speed" min="0" max="5" step="1" value="1"></label><br>
  <label>Arms: <input type="range" id="arms" min="5" max="14" step="1" value="6"></label><br>
  <label>Color: <input type="color" id="color" value="#ff8800"></label>
  <div class="effect-controls">
    <label>Bloom: <input type="range" id="bloom" min="0" max="1.5" step="0.1" value="0.1"></label><br>
    <label>Noise: <input type="range" id="noise" min="0" max="1" step="0.1" value="0.2"></label><br>
    <label>Distortion: <input type="range" id="distortion" min="0" max="0.5" step="0.1" value="0.0"></label><br>
    <label>Tilt: <input type="range" id="tilt" min="0" max="0.5" step="0.05" value="0.15"></label>
  </div>
</div>
<canvas id="glcanvas"></canvas>
<script type="module">
import { vertexShader, fragmentShader } from './shaders.js';

const canvas = document.getElementById("glcanvas");
const renderer = new THREE.WebGLRenderer({ 
    canvas,
    antialias: true,
    alpha: true
});
renderer.setPixelRatio(window.devicePixelRatio);

const scene = new THREE.Scene();

// Static camera for the plane
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, 2);
camera.lookAt(0, 0, 0);

// Orbital camera for the shader effect
const orbitalCamera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
orbitalCamera.position.set(0.7, 0.7, -2);
orbitalCamera.lookAt(0, 0, 0);

// Controls now use orbital camera
const controls = new THREE.OrbitControls(orbitalCamera, canvas);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.screenSpacePanning = false;
controls.minDistance = 2.5;
controls.maxDistance = 5;
controls.rotateSpeed = 0.5;
controls.enableZoom = true;
controls.enablePan = false;
controls.target.set(0, 0, 0);
controls.update();

// Create shader material
const shaderMaterial = new THREE.ShaderMaterial({
    uniforms: {
        u_time: { value: 0 },
        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        u_mouse: { value: new THREE.Vector2() },
        u_color: { value: new THREE.Vector3(1, 0.5, 0) },
        u_speed: { value: 1.0 },
        u_arms: { value: 6 },
        u_bloom: { value: 0.1 },
        u_noise: { value: 0.2 },
        u_distortion: { value: 0.2 },
        u_depth: { value: 1.0 },
        u_viewMatrix: { value: new THREE.Matrix4() },
        u_planeMatrix: { value: new THREE.Matrix4() }
    },
    vertexShader: vertexShader,
    fragmentShader: fragmentShader,
    transparent: true,
    side: THREE.DoubleSide
});

// Create a full-screen quad
const geometry = new THREE.PlaneGeometry(3, 2);
const mesh = new THREE.Mesh(geometry, shaderMaterial);
scene.add(mesh);

// Add white boundary
const wireframeMaterial = new THREE.LineBasicMaterial({ 
    color: 0xffffff,
    linewidth: 1
});
const wireframe = new THREE.LineSegments(
    new THREE.EdgesGeometry(geometry),
    wireframeMaterial
);
wireframe.position.z = 0.000; // Slightly in front
scene.add(wireframe);

// Mouse tracking with normalized coordinates
let mouseX = 0, mouseY = 0;
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) / rect.width;
    mouseY = 1 - (e.clientY - rect.top) / rect.height;
    
    // Calculate target rotation based on mouse position
    targetRotationX = (mouseY - 0.5) * tiltAmount;
    targetRotationY = (mouseX - 0.5) * tiltAmount;
    
    shaderMaterial.uniforms.u_mouse.value.set(mouseX * window.innerWidth, mouseY * window.innerHeight);
});

// Add this code right before the render function
document.addEventListener('mousemove', (e) => {
    const x = (e.clientX / window.innerWidth) * 100;
    const y = (e.clientY / window.innerHeight) * 100;
    document.body.style.setProperty('--mouse-x', `${x}%`);
    document.body.style.setProperty('--mouse-y', `${y}%`);
});

// Control handlers
function hexToRGB(hex) {
  const r = parseInt(hex.slice(1,3), 16) / 255;
  const g = parseInt(hex.slice(3,5), 16) / 255;
  const b = parseInt(hex.slice(5,7), 16) / 255;
  return [r, g, b];
}

let speed = 1.5;
let arms = 6;
let color = hexToRGB('#ff8800');
let bloom = 0.1;
let noiseAmount = 0.2;
let distortion = 0.0;

let tiltAmount = 0.15;
let targetRotationX = 0;
let targetRotationY = 0;
let currentRotationX = 0;
let currentRotationY = 0;

document.getElementById('speed').addEventListener('input', (e) => {
  speed = parseFloat(e.target.value);
});

document.getElementById('arms').addEventListener('input', (e) => {
  arms = parseFloat(e.target.value);
});

document.getElementById('color').addEventListener('input', (e) => {
  color = hexToRGB(e.target.value);
});

document.getElementById('bloom').addEventListener('input', (e) => {
  bloom = parseFloat(e.target.value);
});

document.getElementById('noise').addEventListener('input', (e) => {
  noiseAmount = parseFloat(e.target.value);
});

document.getElementById('distortion').addEventListener('input', (e) => {
  distortion = parseFloat(e.target.value);
});

document.getElementById('tilt').addEventListener('input', (e) => {
  tiltAmount = parseFloat(e.target.value);
});

function render(t) {
    const time = t * 0.001;
    controls.update();  // Update controls before setting uniforms
    
    // Smooth rotation interpolation
    currentRotationX += (targetRotationX - currentRotationX) * 0.1;
    currentRotationY += (targetRotationY - currentRotationY) * 0.1;
    
    // Apply rotation to the mesh
    mesh.rotation.x = currentRotationX;
    mesh.rotation.y = currentRotationY;
    
    // Apply same rotation to wireframe
    wireframe.rotation.copy(mesh.rotation);

    // Update matrices
    orbitalCamera.updateMatrixWorld();
    camera.updateMatrixWorld();
    
    mesh.material.uniforms.u_time.value = time;
    mesh.material.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
    mesh.material.uniforms.u_speed.value = speed;
    mesh.material.uniforms.u_arms.value = arms;
    mesh.material.uniforms.u_color.value.set(color[0], color[1], color[2]);
    mesh.material.uniforms.u_bloom.value = bloom;
    mesh.material.uniforms.u_noise.value = noiseAmount;
    mesh.material.uniforms.u_distortion.value = distortion;
    mesh.material.uniforms.u_viewMatrix.value.copy(orbitalCamera.matrixWorld);
    mesh.material.uniforms.u_planeMatrix.value.copy(camera.matrixWorld);

    renderer.render(scene, camera);
    requestAnimationFrame(render);
}

// Handle window resize
window.addEventListener('resize', () => {
  const width = window.innerWidth;
  const height = window.innerHeight;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  orbitalCamera.aspect = width / height;
  orbitalCamera.updateProjectionMatrix();
  renderer.setSize(width, height);
  shaderMaterial.uniforms.u_resolution.value.set(width, height);
});

const toggleControls = document.getElementById('toggleControls');
const controlsPanel = document.getElementById('controls');

toggleControls.addEventListener('click', () => {
  controlsPanel.classList.toggle('visible');
});

renderer.setSize(window.innerWidth, window.innerHeight);
render(0);
</script>
</body>
</html>
