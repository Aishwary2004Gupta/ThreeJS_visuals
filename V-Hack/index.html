<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Solar Vortex Shader</title>
  <style>
    body { margin: 0; overflow: hidden; background: black; }
    canvas { width: 100vw; height: 100vh; display: block; }
    #controls {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.7);
      padding: 10px;
      border-radius: 5px;
      color: white;
    }
    .effect-controls {
      margin-top: 10px;
      border-top: 1px solid #333;
      padding-top: 10px;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
<div id="controls">
  <label>Speed: <input type="range" id="speed" min="0" max="2" step="0.05" value="1.5"></label><br>
  <label>Arms: <input type="range" id="arms" min="5" max="14" step="1" value="6"></label><br>
  <label>Color: <input type="color" id="color" value="#ff8800"></label>
  <div class="effect-controls">
    <label>Bloom: <input type="range" id="bloom" min="0" max="1.5" step="0.1" value="0.5"></label><br>
    <label>Noise: <input type="range" id="noise" min="0" max="1" step="0.1" value="0.1"></label><br>
    <label>Distortion: <input type="range" id="distortion" min="0" max="0.5" step="0.1" value="0.0"></label>
  </div>
</div>
<canvas id="glcanvas"></canvas>
<script type="x-shader/x-fragment" id="fragShader">
precision highp float;
uniform float u_time;
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform vec3 u_color;
uniform float u_speed;
uniform float u_arms;
uniform float u_bloom;
uniform float u_noise;
uniform float u_distortion;
uniform float u_depth;
uniform mat4 u_viewMatrix;

#define PI 3.14159265359
#define MAX_STEPS 100
#define MAX_DIST 100.0
#define SURF_DIST 0.01

float noise(vec2 p) {
  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

float fbm(vec2 p) {
    float sum = 0.0;
    float amp = 1.0;  // increased from 0.5
    float freq = 1.0;
    for(int i = 0; i < 4; i++) {  // increased octaves
        sum += amp * noise(p * freq);
        freq *= 2.1;  // slightly modified frequency multiplier
        amp *= 0.5;
    }
    return sum * 2.0 - 1.0;  // normalize to [-1, 1] range
}

float sdf_sphere(vec3 p, float r) {
    return length(p) - r;
}

float map(vec3 p) {
    // Remove sphere constraint and create flowing shape
    float angle = atan(p.y, p.x);
    float radius = length(p.xz);
    float height = p.y;
    
    // Enhanced spiral pattern
    float spiral = sin(angle * u_arms + radius * 2.5 - u_time * u_speed) * 0.7;
    spiral += cos(height * 3.0 + angle * 2.0 + u_time * u_speed * 0.3) * 0.5;
    
    // Create flowing boundaries
    float shape = length(p) - (1.5 + spiral * 0.4);
    
    // Enhanced flowing distortion
    vec3 fbmVal = vec3(
        fbm(p.xy + vec2(u_time * 0.2)),
        fbm(p.yz + vec2(u_time * 0.15)),
        fbm(p.xz + vec2(u_time * 0.1))
    );
    
    // Combine with more freedom
    return shape + dot(fbmVal, vec3(0.4)) * u_distortion;
}

vec3 getNormal(vec3 p) {
    vec2 e = vec2(0.01, 0.0);
    return normalize(vec3(
        map(p + e.xyy) - map(p - e.xyy),
        map(p + e.yxy) - map(p - e.yxy),
        map(p + e.yyx) - map(p - e.yyx)
    ));
}

float raymarch(vec3 ro, vec3 rd) {
    float d0 = 0.0;
    float glow = 0.0;
    
    for(int i = 0; i < MAX_STEPS; i++) {
        vec3 p = ro + rd * d0;
        float ds = map(p) * 0.7; // Soften the surface for more fluid look
        if(ds < SURF_DIST || d0 > MAX_DIST) break;
        d0 += ds;
        glow += 0.1 / (1.0 + ds * ds * 8.0); // Add volumetric glow
    }
    
    return d0;
}

void main() {
    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / min(u_resolution.x, u_resolution.y);
    
    // Fixed camera ray setup
    vec3 ro = vec3(0.0, 0.0, 3.0);  // Fixed camera position
    vec3 rd = normalize(vec3(uv.x, uv.y, -1.0));  // Simple ray direction
    
    // Transform ray by view matrix
    mat4 viewMatrix = inverse(u_viewMatrix);
    ro = (viewMatrix * vec4(ro, 1.0)).xyz;
    rd = (viewMatrix * vec4(rd, 0.0)).xyz;
    
    float d = raymarch(ro, rd);
    vec3 p = ro + rd * d;
    vec3 n = getNormal(p);
    
    // Always start with a base color instead of vec3(0.0)
    vec3 color = u_color * 0.15; // Base ambient color
    
    if(d < MAX_DIST) {
        vec3 baseColor = u_color;
        vec3 lightPos = vec3(2.0, 2.0, 4.0);
        vec3 l = normalize(lightPos - p);
        
        float diff = max(dot(n, l), 0.0);
        vec3 h = normalize(l - rd);
        float spec = pow(max(dot(n, h), 0.0), 16.0);  // Reduced specular power
        float fresnel = pow(1.0 - max(dot(n, -rd), 0.0), 2.0);  // Softer fresnel
        
        // Stronger base visibility
        float density = 1.0 - smoothstep(0.0, 1.0, length(p));
        float glow = exp(-2.0 * abs(map(p)));  // Increased glow
        
        // Add these effects to the base color instead of replacing it
        color += baseColor * (diff * 0.7 + 0.3);  // Increased ambient
        color += vec3(1.0) * spec * 0.5;
        color += baseColor * fresnel * 0.8;
        color += baseColor * glow * density * (u_bloom * 3.0);  // Increased bloom effect
        
        // Softer depth falloff
        color *= exp(-d * 0.1);
    }
    
    gl_FragColor = vec4(color, 1.0);
}
</script>
<script type="x-shader/x-vertex" id="vertShader">
varying vec2 vUv;
varying vec3 vPosition;

void main() {
    vUv = uv;
    vPosition = position;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
</script>
<script>
const canvas = document.getElementById("glcanvas");
const renderer = new THREE.WebGLRenderer({ 
    canvas,
    antialias: true,
    alpha: true
});
renderer.setPixelRatio(window.devicePixelRatio);

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 0, -2); // Changed from positive to negative Z
camera.lookAt(0, 0, 0); // Changed to look at center

const controls = new THREE.OrbitControls(camera, canvas);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.screenSpacePanning = false;
controls.minDistance = 2.5; // Increased minimum distance
controls.maxDistance = 5;
controls.rotateSpeed = 0.5;
controls.enableZoom = true;
controls.enablePan = false;
controls.target.set(0, 0, 0);

// Add initial rotation to match the image
controls.autoRotate = false; // Disable auto-rotation
controls.update();

// Create shader material
const shaderMaterial = new THREE.ShaderMaterial({
    uniforms: {
        u_time: { value: 0 },
        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
        u_mouse: { value: new THREE.Vector2() },
        u_color: { value: new THREE.Vector3(1, 0.5, 0) },
        u_speed: { value: 1.0 },
        u_arms: { value: 6 },
        u_bloom: { value: 0.5 },
        u_noise: { value: 0.1 },
        u_distortion: { value: 0.2 },
        u_depth: { value: 1.0 },
        u_viewMatrix: { value: new THREE.Matrix4() }
    },
    vertexShader: document.getElementById("vertShader").textContent,
    fragmentShader: document.getElementById("fragShader").textContent,
    transparent: true,
    side: THREE.DoubleSide
});

// Create a full-screen quad
const geometry = new THREE.PlaneGeometry(3, 2);
const mesh = new THREE.Mesh(geometry, shaderMaterial);
// mesh.rotation.x = Math.PI; // Rotate 180 degrees
scene.add(mesh);

// Add white boundary
const wireframeMaterial = new THREE.LineBasicMaterial({ 
    color: 0xffffff,
    linewidth: 1
});
const wireframe = new THREE.LineSegments(
    new THREE.EdgesGeometry(geometry),
    wireframeMaterial
);
wireframe.position.z = 0.000; // Slightly in front
scene.add(wireframe);

// Mouse tracking with normalized coordinates
let mouseX = 0, mouseY = 0;
canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) / rect.width;
    mouseY = 1 - (e.clientY - rect.top) / rect.height;
    shaderMaterial.uniforms.u_mouse.value.set(mouseX * window.innerWidth, mouseY * window.innerHeight);
});

// Control handlers
function hexToRGB(hex) {
  const r = parseInt(hex.slice(1,3), 16) / 255;
  const g = parseInt(hex.slice(3,5), 16) / 255;
  const b = parseInt(hex.slice(5,7), 16) / 255;
  return [r, g, b];
}

let speed = 1.5;
let arms = 6;
let color = hexToRGB('#ff8800');
let bloom = 0.5;
let noiseAmount = 0.1;
let distortion = 0.0;

document.getElementById('speed').addEventListener('input', (e) => {
  speed = parseFloat(e.target.value);
});

document.getElementById('arms').addEventListener('input', (e) => {
  arms = parseFloat(e.target.value);
});

document.getElementById('color').addEventListener('input', (e) => {
  color = hexToRGB(e.target.value);
});

document.getElementById('bloom').addEventListener('input', (e) => {
  bloom = parseFloat(e.target.value);
});

document.getElementById('noise').addEventListener('input', (e) => {
  noiseAmount = parseFloat(e.target.value);
});

document.getElementById('distortion').addEventListener('input', (e) => {
  distortion = parseFloat(e.target.value);
});

function render(t) {
    const time = t * 0.001;
    
    controls.update();  // Update controls before setting uniforms
    
    // Update view matrix uniform
    camera.updateMatrixWorld();
    camera.matrixWorldInverse.copy(camera.matrixWorld).invert();
    
    mesh.material.uniforms.u_time.value = time;
    mesh.material.uniforms.u_resolution.value.set(window.innerWidth, window.innerHeight);
    mesh.material.uniforms.u_speed.value = speed;
    mesh.material.uniforms.u_arms.value = arms;
    mesh.material.uniforms.u_color.value.set(color[0], color[1], color[2]);
    mesh.material.uniforms.u_bloom.value = bloom;
    mesh.material.uniforms.u_noise.value = noiseAmount;
    mesh.material.uniforms.u_distortion.value = distortion;
    mesh.material.uniforms.u_viewMatrix.value.copy(camera.matrixWorld);  // Use world matrix instead of inverse

    renderer.render(scene, camera);
    requestAnimationFrame(render);
}

// Handle window resize
window.addEventListener('resize', () => {
  const width = window.innerWidth;
  const height = window.innerHeight;
  camera.aspect = width / height;
  camera.updateProjectionMatrix();
  renderer.setSize(width, height);
  shaderMaterial.uniforms.u_resolution.value.set(width, height);
});

renderer.setSize(window.innerWidth, window.innerHeight);
render(0);
</script>
</body>
</html>
